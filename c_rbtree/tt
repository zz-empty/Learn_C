#include "rbtree.h"
// 删除节点
void rb_delete(RBTree *tree, int key) {
    // 查找要删除的节点
    RBNode *z = tree->root;
    while (z != tree->nil) {
        if (z->key == key) break;
        if (z->key < key) z = z->left;
        else z = z->right;
    }

    // 没找到
    if (z == tree->nil) return;
    
    // 找到了
    RBNode *y = z;  // y是实际删除的结点
    Color y_original_color = y->color;  // 保存y的颜色
    RBNode *x;      // 确定替换节点x  用nil, 或者子树，或者最小后继

    // z 没有左子树, 用右子树替代
    if (z->left == tree->nil) {
        x = z->right;
        if (z->parent == tree->nil) {   // z是根节点
            tree->root = x;
        } else if (z == z->parent->left) {  
            z->parent->left = x;    // z是父节点的左孩子
        } else {
            z->parent->right = x;   // z是父节点的右孩子
        }
        x->parent = z->parent;  
    }    
    // z 没有右子树, 用左子树替代
    else if (z->right == tree->nil) {
        x = z->left;
        if (z->parent == tree->nil) {   // z是根节点
            tree->root = x;
        } else if (z == z->parent->left) {  
            z->parent->left = x;    // z是父节点的左孩子
        } else {
            z->parent->right = x;   // z是父节点的右孩子
        }
        x->parent = z->parent;  
    }    
    // z 有两个子树, 用后继节点替代
    else {
        y = tree_minimum(tree, z->right); // z的最小后继
        y_original_color = y->color;
        x = y->right;   // 最小后继的右节点

        // 将y从原有结构中摘除
        if (y->parent == z) {
            // y是z的直接子节点
            x->parent = y;
        } else {
            // y不是z的直接子节点, 将y取走后，修改原y所在的结构
            if (y->parent == tree->nil) {
                tree->root = x;
            } else if (y == y->parent->left) {
                y->parent->left = x;
            } else {
                y->parent->right = x;
            }
            x->parent = y->parent;

            // 将z的右节点挂到y上
            y->right = z->right;
            y->right->parent = y;
        }

        // 用y替换z
        if (z->parent == tree->nil) {
            tree->root = y;
        } else if (z == z->parent->left) {
            z->parent->left = y;
        } else {
            z->parent->right = y;
        }
        y->parent = z->parent;

        y->left = z->left;
        y->left->parent = y;
        y->color = z->color;
    }

    // 如果y是黑色节点，那么删除后需要调整红黑树, 使其黑色路径相同
    if (y_original_color == BLACK) {
        delete_fixup(tree, x);
    }

    free(z);    // 释放z节点
}
