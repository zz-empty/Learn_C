# C

> 数据结构：数组，链表，栈（顺序，链式），队列（循环，链式），二叉树

> 排序算法：冒泡，选择，插入，希尔，快排，堆排，归并，计数

> 查找算法：二分查找，哈希查找，二叉排序树，红黑树

<br>
<br>



## 1. 打印  
    
**1.1 九九乘法表**

**1.2 打印菱形**

**1.3 空心菱形**

**1.4 心形**
    
- 练习:循环、控制边界

<br>
<br>



## 2. 数组

**2.1 找有序数组的公共元素**

    - 思路：双指针    
    - 自定义函数: 生成有序的随机数组，打印数组，有序排序，找出两个数组的公共元素 

**2.2 找数组（无重复元素）的最大值和次大值** 

    - 思路1：先找最大值，然后与最后一个交换并缩减规模，再找次大值
    - 思路2：先找最大值，记录最大值下标。再找次大值（不能与最大值下标相同） 
    - 自定义函数：生成有序的随机数组，打印整形数组，选择排序，数组去重

**2.3 在数量为n的整形数组中，有一个元素出现次数超过一半，找出它**
    
    - 思路：定义一个结构体，存储每个元素的值和其出现次数，如果某个元素的次数超过大小的一半就返回

**2.4 找数组中的两个元素，这两个元素的绝对值是最小的**
    
    - 思路：先排序，再遍历
    - 自定义函数：生成随机数组，选择排序，数组去重，打印数组


**2.5 有一个大小为1001的数组，里面有1~1000的所有数字，但有一个是重复的，找出它**
    
    - 思路：计算出1~1000的总和，与数组的总和作差


<br>
<br>





## 3. 日历



**3.1 输入年月日，输出该日期的下一天的年月日**

    - 思路：判断边界，年末，月末，闰年
    - 自定义函数：求出一个月的最大天数


**3.2 输入年月日，输出该日期是当年的第几天**

    - 思路：从一月累加到上月的总天数，再加上当月天数

**3.3 求任意两个日期相差的天数**

    - 思路1：算出两个日期距离1900年1月1日的天数，再相减
    - 思路2：小年到大年的去年的天数，加上大年当年的天数，加上小年的剩余天数

**3.4 输入年月日，输出该日期是星期几**

    - 思路：算出距离1900年1月1日的天数，再对7取余

**3.5 输入日期，输出经过n天以后的日期和星期**

    - 思路：算出当前日期+n天后的总天数（距离1900-1-1），再通过天数得出日期和星期

**3.6 输入年月，输出该月的日历**

    - 思路：根据年月，得出该月的最大天数和第一天的星期，再打印

**3.7 输入年，输出一整年的日历**

    - 思路：用两个二维数组存储两个月的日历，再并行打印

<br>
<br>


## 4. 计算

**4.1 从键盘上输入字符** 

    ​a 分别统计一下其中字母，数字，其他字符的个数
    ​b 将统计的字母，数字，其他字符的个数以柱状图的形式打印（按照数量关系排序）

    - 思路：用结构体数组，存储各种字符的名字和数量，然后排序这个数组。然后打印max_cnt行，从大往小遍历，达到了小的高度就开始打印。

**4.2 进制转换** 

    ​a 将10进制数转换成2进制数（使用字符数组存储）
    ​b 将2进制数（使用字符数组存储）转换成10进制数（使用整型存储）
    ​c 将10进制数转换成16进制数（使用字符数组存储）
    ​d 将16进制数（使用字符数组存储）转换成10进制数（使用整型存储）

    - 思路：  
        将十进制取余2放入字符数组，再对十进制除以2，直到十进制数为0，之后逆转字符数组
        依次取出字符数组中的字符，sum += sum << 1 | arr[i] - '0'; 
        将十进制数取余16后放入字符数组，再对十进制数除以16，直到十进制数为0，再逆转字符数组
        依次取出字符数组中的字符，sum += sum * 16 + char_to_value(arr[i]);

**4.3 统计一个整型数字的内存内容中有多少个1（注意正负数都要计算）**

    - 思路：每次取出内存中的最后一位bit， if(bit & 1), ++count

**4.4 独特数（101、102、102）**

    ​a 101个数，其中存在50对重复数，1个独特数，求独特数 (提示用异或)
    b 102个数，其中存在50对重复数，2个互不相同的独特数，求这两个独特数（提示想方设法转换成a情况）
    ​c 103个数，其中存在50对重复，3个互不相同的独特数，求这三个独特数

    - 思路：
        对所有数进行异或，结果就是独特数
        对所有数进行异或，得到两个独特数的异或和xor，再通过xor和-xor得到一个分割器，用分割器分割成两个数组，每个数组异或和都会得出一个独特数
        存在三个独特数异或和为0的情况，如果异或和为0，就用hash表处理数组，再找出三个独特数。如果不为0可以用分割器处理



**4.5 给出两个可相乘的矩阵，打印出它们的乘积**

    - 思路：用矩阵相乘公式

**4.6 蛇形遍历方阵，输入一个整数n，按照顺时针盘旋的方式填充一个n*n的方阵**

    - 思路：用一个二维数组指示方向（右、下、左、上），
            在从1填充到n*n，遇到边界或者下一个已填充的情况就更改方向，否则就继续依次填充


**4.7 从(0, 0)到(m, n) 每次走一步（纵坐标加一或横坐标加一），只能向上或者向右走，有多少种路径走到(m, n)**

    - 思路：采用递归算法，递归的出口是 if(m == 0 || n == 0) return 1;






<br>
<br>

## 5. 字符串


**5.1 格式化字符串**

    1-将包含字符数字的字符串分开,使得分开后的字符串前一部分是数字后一部分是字母
    2-将字符串中的空格替换成“%020”

**5.2 删除字符串中的元素**
   
    3-删除字符串中指定的字符
    4-删除有序数组中的重复元素
    5-删除句子当中的多余空格，使得单词与单词之间只有一个空格

**5.3 字符串拆分**
    
    6-输入一行字符串（单词和若干空格）， 输出该行单词个数
    7-输入一行字符串（单词和若干空格），输出该行单词（每个单词一行）

    - 思路：利用辅助字符串，判断边界。如果在一行操作就需要双指针

**5.4 利用字符数组，实现大整数加法（要考虑正负数的情况）**

    - 思路：
        利用结构体存储分别存储数据部分和符号位，逆序存储两个大整数
        如果符号位相同，直接相加。注意进位，最后逆转
        如果符号位不同，先找到绝对值大的，再相减，最后逆转
    
    
**5.5 用数组指针和二级指针分别实现字符串数组的排序**

    - 思路：直接用原数组排序很浪费时间且灵活度不高。建立一个数组索引，排序索引的效率很高实用性强。



<br>
<br>

## 6. 链表

**6.1 增删查改：头插，尾插、有序插入，按位删除，按值删除**


**6.2 合并两个有序链表**

    - 思路：顺序取出第二个链表的结点，头插进第一个链表

**6.3 链表逆置**

    - 思路：顺序取出第一个节点后续的所有节点，挨个头插

**6.4 找链表的第4个节点，找链表的中间节点**
    
**6.5 判断链表是否有环**
    
**6.6 判断两个链表是否相交**

**6.7 删除链表中的连续重复元素**

    - 以上思路：双指针（快慢指针）

**6.8 链表拆分，奇数结点组成一个链表，偶数结点组成一个链表**

    - 思路：设置一个计数器用来判断当前奇偶，顺序取出链表节点




**6.9 使用链表实现大整数加法。（计算两个整数（该整数的值可能超过一个整型变量所能表示的范围）的加法）**

    - 思路：
        设置一个大整数结构体，存储符号位和链表（逆序存储数字的每个位）
        1. 先处理两个读取到的数字（字符串类型），转成大整数
        2. 相加时，分两种情况：同符号位和异符号位
        3. 最后将相加后的大整数，转成字符串，输出
    


<br>
<br>

## 7. 栈


**7.1 实现顺序栈**

    - 顺序栈数据成员：数据域，栈顶指针（指向栈顶元素）
    - 顺序栈成员函数：
          初始化栈
          判空
          判满
          入栈
          弹栈
          查看栈顶
          打印顺序栈


<br>
<br>

## 8. 队列

**8.1 实现循环队列**

    - 循环队列数据成员：数据域，队头指针，队尾指针
    - 循环队列成员函数：
        初始化队列
        判空
        判满
        入队
        出队
        查看队首元素
        获取队列大小
        打印队列






**8.2 实现链式队列**

    - 链式队列数据成员：队头指针，队尾指针
    - 链式队列成员函数：
        初始化队列
        判空
        入队
        出队
        获取队首元素
        打印队列



<br>
<br>


## 9. 二叉树

**9.1 二叉树的层次建树**

    - 二叉树结点构成：数据域，左孩子指针，右孩子指针
    - 层次建树思路：
          利用辅助队列从头处理所有原始数据
          新建树节点node时，也创建一个队列结点并入队
          如果根节点空，将node赋值给根节点
          如果根节点不为空，设置队首元素的孩子结点，当放置完右孩子后出队



<br>
<br>

## 10. 排序

**10.1 冒泡排序，选择排序，插入排序，希尔排序**

    - 冒泡排序思路：比较n-1次，每次从头将最大值挨个比较出来，再缩小数据的规模
        平均时间复杂度：O(n^2)
    
    - 选择排序思路：比较n-1次，每次找出最大值的下标，将其对应的元素与当前规模的最后一位交换，再缩小数据的规模
        平均时间复杂度：O(n^2)
    
    - 插入排序思路：手牌从1增加到n，牌堆从n-1到0。记录每张来牌，后移所有大于当前来牌的元素，再插入那个位置。
        平均时间复杂度：O(n^2)
    
    - 希尔排序思路：优化了的插入排序，先进行预排序，缩小增量排序
        平均时间复杂度：O(n^1.3)


    
**10.2 快速排序，堆排序，归并排序，计数排序**

    - 快速排序思路：分而治之。随机找一个枢纽，枢纽左边都比它小，右边都大于或等于它。递归处理数组，直到数组规模<=1
        平均时间复杂度：O(n^logn)
    
    - 堆排序思路：利用大根堆
        1. 先对整个数组建立一个大根堆，从最后一个父结点开始建到第一个结点
        2. 将大根堆的堆顶与最后元素进行交换，缩小数据规模，继续调整大根堆
        3. 重复上一步，直到数据规模<=1
        平均时间复杂度：O(n^logn)
    
    - 归并排序思路：递归处理左右两边，最后合并有序数组
        平均时间复杂度：O(n^logn)
    
    - 计数排序思路：
            能确定数据的范围时使用，是最快的排序，适合处理重复的数据
            创建一个count数组，下标就是原数组的值，初始化count数组
            再遍历一遍count数组，重新构建原数组
        平均时间复杂度：O(1)
        使用场景：要求最快时间；数据范围可控；数据重复    


**10.3 寻找第k大的数**

    - 思路：用快排或者堆排的时间复杂度为O(n)，如果需要去重可以先用计数排序处理一下

    快排：不断划分数组得到pivot，如果pivot == len - k就说明找到了
    堆排：先维护一个数量为k的小根堆，用剩余元素挨个挑战堆顶，如果大于堆顶就与堆顶交换然后调整堆，最后返回堆顶

<br>
<br>

## 11. 查找

**11.1 二分查找**

    - 思路：
        1. 要先确保数组数据是有序的。假设是升序的。
        2. while (有效的搜索范围)
            如果比中间节点小，去左边找。如果比中间节点大，去右边找。
            如果等于中间节点，说明找到了，返回节点
        3. 如果运行到这说明没找到，返回NULL
        
        时间复杂度：O(logn)

<br>


**11.2 哈希查找**

    - 思路：
        先对数组数据进行处理，得到一个哈希表
        1. 新建一张哈希表hashtable，初始化哈希表的元素为-1
        2. 遍历每个元素，先进行哈希处理得到哈希值hash，然后hashtable[hash] = 下标
        搜索查找值，先对其进行哈希处理得到一个哈希值。
        如果hashtable[hash] == -1说明没找到，否则就能找到下标。
        
        时间复杂度：O(1)
        处理哈希冲突：链表法，开放寻址法

<br>


**11.3 二叉搜索树**

    - 思路：
        先对数据建树，在查找。为了防止查找过深，还需要适当对树进行旋转。
        平衡的二叉搜索树是AVL树，实现比较复杂，插入和删除要旋转很多次，不太实用。

<br>

**11.4 红黑树**

**红黑树插入**
        
    首先插入节点
    1. 寻找插入位置，如果重复就退出
    2. 插入新节点，将新节点染红
    3. 调整整体颜色
    
    插入后调整颜色
    1. 父亲是黑色，不用处理
    2. 父亲是红色
        1. 叔叔也是红色，父叔染黑，爷染红，重新插入爷
        2. 叔叔是黑色
            1. 左腰子型父左旋。父染黑爷染红，爷右旋。
            2. 左裙子型，父染黑爷染红，爷右旋。
            3. 右腰子型父右旋，父染黑爷染红，爷左旋。
            4. 右裙子型，父染黑爷染红，爷左旋。



**红黑树删除**
        
    首先删除节点 z
    1. 找被删除的节点，如果找不到直接退出
    2. 度为0直接删除，修改父的孩子指针
    3. 度为1用孩子结点替换，修改父的孩子指针和孩子的父指针，然后删除
    4. 度为2，先找直接后继 y，调整直接后继所在的结构然后将 z 的右子树挂到 y 的右边，用直接后继替换，然后删除
    5. 如果直接后继是黑的，调整整体颜色
    
    
    在被删除节点 x 所在位置调整颜色
    1. while（如果节点 x 是黑的，而且不是根节点）
        1. 如果x是父节点的左孩子
            1. 如果兄红：兄染黑父染红，父左旋，更新兄弟节点
            2. 如果兄黑&兄两个孩子都黑：兄弟染红，x改为父结点继续处理
            3. 如果兄黑&兄左红右黑（右腰子型）：兄左染黑，兄染红，兄右旋，更新兄弟节点
            4. 如果兄黑&兄右红左黑（右裙子型）：兄染父色，兄右染黑父染黑，父左旋，x设为root
        2. 如果x是父节点的右孩子
            1. 如果兄红：兄染黑父染红，父右旋，更新兄弟节点
            2. 如果兄黑&兄孩子都黑：兄染红，x改为父节点继续处理
            3. 如果兄黑&兄右红左黑（左腰子型）：兄右染黑，兄染红，兄左旋，更新兄弟节点
            4. 如果兄黑&兄左红右黑（左裙子型）：兄染父色，兄左染黑父染黑，父右旋，x设为root
    2. 将 x 染黑（x为红色或者是root，都会被染黑）



<br>
<br>

## 12. 文件

**12.1 处理文件中的非小写字母**

    思路：
        
